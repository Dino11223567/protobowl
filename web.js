// Generated by CoffeeScript 1.3.3
var Channel, active_channels, app, cumsum, damlev, express, fs, init_channel, io, port, questions, syllables;

express = require('express');

app = express.createServer(express.logger());

io = require('socket.io').listen(app);

io.configure(function() {
  io.set("transports", ["xhr-polling"]);
  io.set("polling duration", 10);
  return io.set("log level", 2);
});

fs = require('fs');

damlev = require('./levenshtein').levenshtein;

questions = [];

fs.readFile('sample.txt', 'utf8', function(err, data) {
  var line;
  if (err) {
    throw err;
  }
  return questions = (function() {
    var _i, _len, _ref, _results;
    _ref = data.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      _results.push(JSON.parse(line));
    }
    return _results;
  })();
});

app.set('views', __dirname);

app.set('view options', {
  layout: false
});

app.use(express["static"](__dirname));

active_channels = {};

syllables = require('./syllable').syllables;

cumsum = function(list, rate) {
  var num, sum, _i, _len, _results;
  sum = 0;
  _results = [];
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    num = list[_i];
    _results.push(sum += Math.round(num) * rate);
  }
  return _results;
};

Channel = (function() {

  function Channel(name) {
    var _this = this;
    console.log("initializing channel", name);
    this.ns = io.of(name);
    this.timeOffset = 0;
    this.timeCallbacks = [];
    this.revealDelay = 2 * 1000;
    this.nextQuestion();
    this.ns.on('connection', function(sock) {
      return _this.addUser(sock);
    });
  }

  Channel.prototype.onTime = function(time, callback) {
    this.timeCallbacks.push([this.getTime() + time, callback]);
    return this.checkTime();
  };

  Channel.prototype.checkTime = function() {
    var continuing, execution_queue, fn, time, _i, _j, _len, _len1, _ref, _ref1, _results,
      _this = this;
    continuing = [];
    execution_queue = [];
    _ref = this.timeCallbacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], time = _ref1[0], fn = _ref1[1];
      if (time <= this.getTime()) {
        execution_queue.push(fn);
      } else {
        setTimeout(function() {
          return _this.checkTime();
        }, time - this.getTime());
        continuing.push([time, fn]);
      }
    }
    this.timeCallbacks = continuing;
    _results = [];
    for (_j = 0, _len1 = execution_queue.length; _j < _len1; _j++) {
      fn = execution_queue[_j];
      _results.push(fn());
    }
    return _results;
  };

  Channel.prototype.getTime = function() {
    if (this.timeFreeze) {
      return this.timeFreeze;
    } else {
      return +(new Date) - this.timeOffset;
    }
  };

  Channel.prototype.getTiming = function() {
    var word;
    return {
      list: (function() {
        var _i, _len, _ref, _results;
        _ref = this.question.question.split(" ");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          word = _ref[_i];
          _results.push(syllables(word));
        }
        return _results;
      }).call(this),
      rate: 1000 * 60 / 2 / 300
    };
  };

  Channel.prototype.nextQuestion = function() {
    var list, rate, _ref,
      _this = this;
    this.timeCallbacks = [];
    this.completed = false;
    this.timeFreeze = 0;
    this.countDuration = 0;
    this.countStart = 0;
    this.tableOwner = null;
    this.question = questions[Math.floor(questions.length * Math.random())];
    this.question.question = this.question.question.replace(/FTP/g, 'For 10 points').replace(/^\[.*?\]/, '').replace(/\n/g, ' ');
    delete this.question.pKey;
    this.question.timing = this.getTiming();
    this.lastTime = this.getTime();
    _ref = this.question.timing, list = _ref.list, rate = _ref.rate;
    this.ns.emit("sync", this.synchronize(true));
    return this.onTime(cumsum(list, rate).slice(-1)[0] + this.revealDelay, function() {
      return setTimeout(function() {
        return _this.nextQuestion();
      }, 2000);
    });
  };

  Channel.prototype.buzz = function(data, callback, sock) {
    var _this = this;
    if (this.timeFreeze) {
      if (sock === this.tableOwner) {
        return callback("you dont have too much time left!");
      } else {
        return callback("you lost the game!");
      }
    } else {
      this.countDuration = 10 * 1000;
      this.countStart = +(new Date);
      sock.name = data.name;
      sock.guess = "";
      this.tableOwner = sock;
      this.freeze();
      this.freezeTimeout = setTimeout(function() {
        return _this.unfreeze();
      }, this.countDuration);
      return callback("who's awesome? you are!");
    }
  };

  Channel.prototype.freeze = function() {
    this.timeFreeze = this.getTime();
    return this.ns.emit("sync", this.synchronize());
  };

  Channel.prototype.unfreeze = function() {
    if (this.timeFreeze) {
      clearTimeout(this.freezeTimeout);
      this.timeOffset = new Date - this.timeFreeze;
      this.timeFreeze = 0;
      this.tableOwner = null;
      this.countDuration = 0;
      this.ns.emit("sync", this.synchronize());
      console.log("time circuits", this.timeOffset);
    }
    return this.checkTime();
  };

  Channel.prototype.checkAnswer = function(guess) {
    var a, b;
    a = guess.toLowerCase().replace(/[^a-z0-9]/g, '');
    b = this.question.answer.toLowerCase().replace(/\(.*\)/g, '').replace(/\[.*\]/g, '').replace(/[^a-z0-9]/g, '');
    return damlev(a, b) < 2;
  };

  Channel.prototype.guess = function(data, callback, sock) {
    var _this = this;
    if (sock === this.tableOwner) {
      sock.guess = data.guess;
      if (data.final === true) {
        this.unfreeze();
        if (this.checkAnswer(data.guess)) {
          callback("yay");
          this.completed = true;
          this.freeze();
          return setTimeout(function() {
            return _this.nextQuestion();
          }, 2000);
        } else {
          return callback("nay");
        }
      } else {
        callback("okay");
        return this.ns.emit("sync", this.synchronize());
      }
    } else {
      return callback("not allowed to guess");
    }
  };

  Channel.prototype.addUser = function(sock) {
    var _this = this;
    console.log("Adding a new user to the channel");
    sock.emit('sync', this.synchronize(true));
    sock.on('echo', function(data, callback) {
      return callback(+(new Date));
    });
    sock.on('disconnect', function() {
      return console.log("user disconnected");
    });
    sock.on('buzz', function(data, callback) {
      return _this.buzz(data, callback, sock);
    });
    sock.on('guess', function(data, callback) {
      return _this.guess(data, callback, sock);
    });
    sock.on('unpause', function(data, callback) {
      return _this.unfreeze();
    });
    sock.on('pause', function(data, callback) {
      return _this.freeze();
    });
    return sock.on('skip', function(data, callback) {
      _this.completed = true;
      _this.freeze();
      return setTimeout(function() {
        return _this.nextQuestion();
      }, 2000);
    });
  };

  Channel.prototype.synchronize = function(all) {
    var data, _ref, _ref1;
    data = {
      time: this.getTime(),
      lastTime: this.lastTime,
      revealDelay: this.revealDelay,
      tableOwner: (_ref = this.tableOwner) != null ? _ref.name : void 0,
      completed: this.completed,
      guess: (_ref1 = this.tableOwner) != null ? _ref1.guess : void 0,
      countDuration: Math.max(0, this.countDuration - (new Date - this.countStart)),
      timeFreeze: this.timeFreeze
    };
    if (all) {
      data.question = this.question;
    }
    return data;
  };

  return Channel;

})();

init_channel = function(name) {
  if (!(name in active_channels)) {
    return active_channels[name] = new Channel(name);
  }
};

io.sockets.on('connection', function(sock) {
  return console.log("got stuff as in connecting");
});

app.get('/:channel', function(req, res) {
  var name;
  name = "/" + req.params.channel;
  init_channel(name);
  return res.render('index.jade', {
    name: name,
    initial: JSON.stringify(active_channels[name].synchronize(true))
  });
});

app.get('/', function(req, res) {
  var noun, people, pick, verb;
  people = 'kirk,feynman,huxley,robot,ben,batman,panda,pinkman,superhero,celebrity,traitor,alien,lemon';
  verb = 'on,enveloping,eating,drinking,in,near,sleeping,destruction';
  noun = 'mountain,drugs,house,asylum,elevator,scandal,planet,school,brick';
  pick = function(list) {
    var n;
    n = list.split(',');
    return n[Math.floor(n.length * Math.random())];
  };
  return res.redirect('/' + pick(people) + "-" + pick(verb) + "-" + pick(noun));
});

port = process.env.PORT || 5000;

app.listen(port, function() {
  return console.log("listening on", port);
});
