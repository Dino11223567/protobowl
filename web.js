// Generated by CoffeeScript 1.3.3
var Channel, active_channels, app, cumsum, express, fs, init_channel, io, port, questions, syllables;

express = require('express');

app = express.createServer(express.logger());

io = require('socket.io').listen(app);

io.configure(function() {
  io.set("transports", ["xhr-polling"]);
  return io.set("polling duration", 10);
});

fs = require('fs');

questions = [];

fs.readFile('sample.txt', 'utf8', function(err, data) {
  var line;
  if (err) {
    throw err;
  }
  return questions = (function() {
    var _i, _len, _ref, _results;
    _ref = data.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      _results.push(JSON.parse(line));
    }
    return _results;
  })();
});

app.set('views', __dirname);

app.set('view options', {
  layout: false
});

app.use(express["static"](__dirname));

active_channels = {};

syllables = require('./syllable').syllables;

cumsum = function(list, rate) {
  var num, sum, _i, _len, _results;
  sum = 0;
  _results = [];
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    num = list[_i];
    _results.push(sum += Math.round(num) * rate);
  }
  return _results;
};

Channel = (function() {

  function Channel(name) {
    var _this = this;
    console.log("initializing channel", name);
    this.ns = io.of(name);
    this.timeOffset = 0;
    this.timeCallbacks = [];
    this.revealDelay = 10 * 1000;
    this.nextQuestion();
    this.ns.on('connection', function(sock) {
      return _this.addUser(sock);
    });
  }

  Channel.prototype.onTime = function(time, callback) {
    var _this = this;
    this.timeCallbacks.push([this.getTime() + time, callback]);
    return setTimeout(function() {
      return _this.checkTime();
    }, time);
  };

  Channel.prototype.checkTime = function() {
    var continuing, fn, time, _i, _len, _ref, _ref1,
      _this = this;
    continuing = [];
    _ref = this.timeCallbacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], time = _ref1[0], fn = _ref1[1];
      if (time < this.getTime()) {
        fn();
      } else {
        setTimeout(function() {
          return _this.checkTime();
        }, time - this.getTime());
        continuing.push([time, fn]);
      }
    }
    return this.timeCallbacks = continuing;
  };

  Channel.prototype.getTime = function() {
    if (this.timeFreeze) {
      return this.timeFreeze;
    } else {
      return +(new Date) - this.timeOffset;
    }
  };

  Channel.prototype.getTiming = function() {
    var word;
    return {
      list: (function() {
        var _i, _len, _ref, _results;
        _ref = this.question.question.split(" ");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          word = _ref[_i];
          _results.push(syllables(word));
        }
        return _results;
      }).call(this),
      rate: 1000 * 60 / 2 / 300
    };
  };

  Channel.prototype.nextQuestion = function() {
    var list, rate, _ref,
      _this = this;
    this.timeFreeze = 0;
    this.countDuration = 0;
    this.countStart = 0;
    this.tableOwner = null;
    this.question = questions[Math.floor(questions.length * Math.random())];
    this.question.question = this.question.question.replace(/FTP/g, 'For 10 points').replace(/^\[.*?\]/, '').replace(/\n/g, ' ');
    delete this.question.pKey;
    this.question.timing = this.getTiming();
    this.lastTime = this.getTime();
    _ref = this.question.timing, list = _ref.list, rate = _ref.rate;
    this.onTime(cumsum(list, rate).slice(-1)[0] + this.revealDelay, function() {
      _this.nextQuestion();
      return _this.ns.emit("sync", _this.synchronize(true));
    });
    return this.ns.emit("sync", this.synchronize());
  };

  Channel.prototype.buzz = function(data, callback, sock) {
    var _this = this;
    if (this.timeFreeze) {
      if (sock === this.tableOwner) {
        return callback("you dont have too much time left!");
      } else {
        return callback("you lost the game!");
      }
    } else {
      this.countDuration = 10 * 1000;
      this.countStart = +(new Date);
      this.freeze();
      this.tableOwner = sock;
      this.freezeTimeout = setTimeout(function() {
        return _this.unfreeze();
      }, this.countDuration);
      return callback("who's awesome? you are!");
    }
  };

  Channel.prototype.freeze = function() {
    this.timeFreeze = this.getTime();
    return this.ns.emit("sync", this.synchronize());
  };

  Channel.prototype.unfreeze = function() {
    if (this.timeFreeze) {
      clearTimeout(this.freezeTimeout);
      this.timeOffset = new Date - this.timeFreeze;
      this.timeFreeze = 0;
      this.countDuration = 0;
      this.ns.emit("sync", this.synchronize());
      console.log("time circuits", this.timeOffset);
    }
    return this.checkTime();
  };

  Channel.prototype.addUser = function(sock) {
    var _this = this;
    console.log("Adding a new user to the channel");
    sock.emit('sync', this.synchronize(true));
    sock.on('disconnect', function() {
      return console.log("user disconnected");
    });
    sock.on('buzz', function(data, callback) {
      console.log("buzz");
      return _this.buzz(data, callback, sock);
    });
    return sock.on('unbuzz', function(data, callback) {
      if (sock === _this.tableOwner) {
        _this.unfreeze();
        return callback("okay");
      } else {
        return callback("you dont own this place!");
      }
    });
  };

  Channel.prototype.synchronize = function(all) {
    var data;
    data = {
      time: this.getTime(),
      lastTime: this.lastTime,
      revealDelay: this.revealDelay,
      countDuration: Math.max(0, this.countDuration - (new Date - this.countStart)),
      timeFreeze: this.timeFreeze
    };
    if (all) {
      data.question = this.question;
    }
    return data;
  };

  return Channel;

})();

init_channel = function(name) {
  if (!(name in active_channels)) {
    return active_channels[name] = new Channel(name);
  }
};

io.sockets.on('connection', function(sock) {
  return console.log("got stuff as in connecting");
});

app.get('/:channel', function(req, res) {
  var name;
  name = "/" + req.params.channel;
  init_channel(name);
  return res.render('index.jade', {
    name: name,
    initial: JSON.stringify(active_channels[name].synchronize())
  });
});

app.get('/', function(req, res) {
  var noun, people, pick, verb;
  people = 'kirk,feynman,huxley,robot,ben,batman,panda,pinkman,superhero,celebrity,traitor,alien,lemon';
  verb = 'on,enveloping,eating,drinking,in,near,sleeping,destruction';
  noun = 'mountain,drugs,house,asylum,elevator,scandal,planet,school,brick';
  pick = function(list) {
    var n;
    n = list.split(',');
    return n[Math.floor(n.length * Math.random())];
  };
  return res.redirect('/' + pick(people) + "-" + pick(verb) + "-" + pick(noun));
});

port = process.env.PORT || 5000;

app.listen(port, function() {
  return console.log("listening on", port);
});
