// Generated by CoffeeScript 1.3.3
var Channel, active_channels, app, channelChecker, express, fs, init_channel, io, port, questions;

express = require('express');

app = express.createServer(express.logger());

io = require('socket.io').listen(app);

io.configure(function() {
  io.set("transports", ["xhr-polling"]);
  return io.set("polling duration", 10);
});

fs = require('fs');

questions = [];

fs.readFile('sample.txt', 'utf8', function(err, data) {
  var line;
  if (err) {
    throw err;
  }
  return questions = (function() {
    var _i, _len, _ref, _results;
    _ref = data.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      _results.push(JSON.parse(line));
    }
    return _results;
  })();
});

app.set('views', __dirname);

app.set('view options', {
  layout: false
});

app.use(express["static"](__dirname));

active_channels = {};

Channel = (function() {

  function Channel(name) {
    var _this = this;
    console.log("initializing channel", name);
    this.ns = io.of(name);
    this.timeOffset = 0;
    this.nextQuestion();
    this.ns.on('connection', function(sock) {
      return _this.addUser(sock);
    });
  }

  Channel.prototype.getTime = function() {
    return +(new Date) - this.timeOffset;
  };

  Channel.prototype.nextQuestion = function() {
    var timeDelta;
    this.timeFreeze = 0;
    this.question = questions[Math.floor(questions.length * Math.random())];
    this.lastTime = this.getTime();
    timeDelta = this.question.question.split(" ").length * 1000 * 60 / 600;
    this.nextTime = this.lastTime + timeDelta;
    this.revealTime = this.nextTime + 1000 * 10;
    return this.ns.emit("sync", this.synchronize());
  };

  Channel.prototype.buzz = function(data) {
    this.timeFreeze = this.getTime();
    return this.ns.emit("buzz", {
      time: this.timeFreeze,
      user: data.user
    });
  };

  Channel.prototype.addUser = function(sock) {
    var _this = this;
    console.log("Adding a new user to the channel");
    sock.emit('sync', this.synchronize());
    sock.on('disconnect', function() {
      return console.log("user disconnected");
    });
    sock.on('buzz', function(data) {
      console.log("buzz");
      return _this.buzz(data);
    });
    return sock.on('unbuzz', function() {
      _this.timeOffset += _this.getTime() - _this.timeFreeze;
      _this.timeFreeze = 0;
      _this.ns.emit("sync", _this.synchronize());
      return console.log("time circuits", _this.timeOffset);
    });
  };

  Channel.prototype.synchronize = function() {
    return {
      time: this.getTime(),
      lastTime: this.lastTime,
      nextTime: this.nextTime,
      question: this.question,
      revealTime: this.revealTime,
      timeFreeze: this.timeFreeze
    };
  };

  return Channel;

})();

channelChecker = function() {
  var channel, _results;
  _results = [];
  for (channel in active_channels) {
    _results.push(console.log(channel));
  }
  return _results;
};

setInterval(channelChecker, 1000);

init_channel = function(name) {
  if (!(name in active_channels)) {
    return active_channels[name] = new Channel(name);
  }
};

io.sockets.on('connection', function(sock) {
  return console.log("got stuff as in connecting");
});

app.get('/:channel', function(req, res) {
  var name;
  name = "/" + req.params.channel;
  init_channel(name);
  return res.render('index.jade', {
    name: name
  });
});

app.get('/', function(req, res) {
  var noun, people, pick, verb;
  people = 'kirk,feynman,huxley,robot,ben,batman,panda,pinkman,superhero,celebrity,traitor,alien,lemon';
  verb = 'on,enveloping,eating,drinking,in,near,sleeping,destruction';
  noun = 'mountain,drugs,house,asylum,elevator,scandal,planet,school,brick';
  pick = function(list) {
    var n;
    n = list.split(',');
    return n[Math.floor(n.length * Math.random())];
  };
  return res.redirect('/' + pick(people) + "-" + pick(verb) + "-" + pick(noun));
});

port = process.env.PORT || 5000;

app.listen(port, function() {
  return console.log("listening on", port);
});
