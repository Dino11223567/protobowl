// Generated by CoffeeScript 1.3.3
var fisher_yates, getQuestion, loadQuestions, question_schedule, questions, virtual_server;

questions = [
  {
    "category": "Meta",
    "question_num": 666,
    "tournament": "Metaception Bowl",
    "question": "This application was intended to act as a chat client which could handle single user sessions offline by pretending the user was schizophrenic. It was started primarily because of an argument about how to implement multiplayer and whether or not the DC comics character, the Joker, might say \"Singleplayer is Multiplayer without balls\". For 10 points, name this application that you are almost certainly using right now.",
    "accept": null,
    "difficulty": "HS",
    "year": 2012,
    "answer": "protobowl",
    "round": "Round_10_HSAPQ4Q.pdf"
  }
];

fisher_yates = function(i) {
  var arr, j, _i, _ref, _results;
  if (i === 0) {
    return [];
  }
  arr = (function() {
    _results = [];
    for (var _i = 0; 0 <= i ? _i < i : _i > i; 0 <= i ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  while (--i) {
    j = Math.floor(Math.random() * (i + 1));
    _ref = [arr[j], arr[i]], arr[i] = _ref[0], arr[j] = _ref[1];
  }
  return arr;
};

question_schedule = [];

getQuestion = function() {
  if (question_schedule.length === 0) {
    question_schedule = fisher_yates(questions.length);
  }
  return questions[question_schedule.shift()];
};

virtual_server = {
  pause: function() {
    if (!(sync.attempt || time() > sync.end_time)) {
      return this.freeze();
    }
  },
  unpause: function() {
    if (!sync.attempt) {
      return this.unfreeze();
    }
  },
  set_time: function(ts) {
    return sync.time_offset = serverTime() - ts;
  },
  freeze: function() {
    return sync.time_freeze = time();
  },
  unfreeze: function() {
    if (sync.time_freeze) {
      this.set_time(sync.time_freeze);
      return sync.time_freeze = 0;
    }
  },
  skip: function() {
    return this.new_question();
  },
  init_offline: function() {
    return loadQuestions();
  },
  rename: function(name) {
    return users[public_id].name = name;
  },
  join: function(data) {
    var publicID, publicName;
    publicID = "offline";
    publicName = require('lib/names').generateName();
    console.log("joining stuff", data);
    sync.answer_duration = 1000 * 5;
    sync.time_offset = 0;
    sync.users = [
      {
        guesses: 0,
        interrupts: 0,
        early: 0,
        correct: 0,
        last_action: 0,
        id: publicID,
        name: publicName
      }
    ];
    this.freeze();
    this.new_question();
    sock.server_emit('introduce', {
      user: publicID
    });
    setTimeout(function() {
      return synchronize();
    }, 10);
    return {
      name: publicName,
      id: publicID
    };
  },
  chat: function(msg) {
    sock.server_emit('chat', {
      text: msg.text,
      session: msg.session,
      user: public_id,
      final: msg.final,
      time: serverTime()
    });
    if (msg.final && /lonely/.test(msg.text)) {
      return setTimeout(function() {
        return sock.server_emit('chat', {
          text: "I'm lonely too. Plz talk to meeeee",
          session: "yay" + Math.random(),
          user: public_id,
          final: true,
          time: serverTime()
        });
      }, 1000);
    }
  },
  new_question: function() {
    var cumulative, question, syllables, word;
    sync.attempt = null;
    sync.begin_time = time();
    question = getQuestion();
    sync.info = {
      category: question.category,
      difficulty: question.difficulty,
      tournament: question.tournament,
      num: question.question_num,
      year: question.year,
      round: question.round
    };
    sync.question = question.question.replace(/FTP/g, 'For 10 points').replace(/^\[.*?\]/, '').replace(/\n/g, ' ');
    sync.answer = question.answer.replace(/\<\w\w\>/g, '').replace(/\[\w\w\]/g, '');
    syllables = require('./lib/syllable').syllables;
    sync.timing = (function() {
      var _i, _len, _ref, _results;
      _ref = sync.question.split(" ");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        word = _ref[_i];
        _results.push(syllables(word) + 1);
      }
      return _results;
    })();
    sync.rate = Math.round(1000 * 60 / 3 / 300);
    cumulative = cumsum(sync.timing, sync.rate);
    sync.end_time = sync.begin_time + cumulative[cumulative.length - 1] + sync.answer_duration;
    return synchronize();
  },
  guess: function(data) {
    if (sync.attempt) {
      sync.attempt.text = data.text;
      if (data.final) {
        return this.end_buzz(sync.attempt.session);
      }
    }
  },
  end_buzz: function(session) {
    var checkAnswer, _ref;
    if (((_ref = sync.attempt) != null ? _ref.session : void 0) === session) {
      sync.attempt.final = true;
      checkAnswer = require('./lib/answerparse').checkAnswer;
      sync.attempt.correct = checkAnswer(sync.attempt.text, sync.answer);
      synchronize();
      this.unfreeze();
      if (sync.attempt.correct) {
        users[public_id].correct++;
        if (sync.attempt.early) {
          users[public_id].early++;
        }
        this.set_time(sync.end_time);
      } else if (sync.attempt.interrupt) {
        users[public_id].interrupts++;
      }
      sync.attempt = null;
      return synchronize();
    }
  },
  buzz: function() {
    var cumulative, early_index, session,
      _this = this;
    if (time() <= sync.end_time) {
      session = Math.random().toString(36).slice(2);
      early_index = sync.question.replace(/[^ \*]/g, '').indexOf('*');
      cumulative = cumsum(sync.timing, sync.rate);
      sync.attempt = {
        user: public_id,
        realTime: serverTime(),
        start: time(),
        duration: 8 * 1000,
        session: session,
        text: '',
        early: early_index && time() < sync.begin_time + cumulative[early_index],
        interrupt: time() < sync.end_time - sync.answer_duration,
        final: false
      };
      users[public_id].guesses++;
      this.freeze();
      return this.timeout(serverTime, sync.attempt.realTime + sync.attempt.duration, function() {
        return _this.end_buzz(session);
      });
    }
  },
  timeout: function(metric, time, callback) {
    var diff,
      _this = this;
    diff = time - metric();
    if (diff < 0) {
      return callback();
    } else {
      return setTimeout(function() {
        return _this.timeout(metric, time, callback);
      }, diff);
    }
  }
};

loadQuestions = function(fn) {
  return $.ajax('sample.txt').done(function(text) {
    var line;
    questions = (function() {
      var _i, _len, _ref, _results;
      _ref = text.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(JSON.parse(line));
      }
      return _results;
    })();
    console.log('got questions', questions.length);
    if (fn) {
      return fn();
    }
  });
};

if (!(typeof io !== "undefined" && io !== null)) {
  console.log("initializing server!");
  loadQuestions(function() {
    return sock.server_emit("connect");
  });
}
