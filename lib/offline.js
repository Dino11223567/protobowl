// Generated by CoffeeScript 1.3.3
var countMatches, fisher_yates, getQuestion, listProps, loadQuestions, question_schedule, questions, virtual_server;

questions = [
  {
    "category": "Meta",
    "question_num": 666,
    "tournament": "Metaception Bowl",
    "question": "This application was intended to act as a chat client which could handle single user sessions offline by pretending the user was schizophrenic. It was started primarily because of an argument about how to implement multiplayer and whether or not the DC comics character, the Joker, might say \"Singleplayer is Multiplayer without balls\". For 10 points, name this application that you are almost certainly using right now.",
    "accept": null,
    "difficulty": "HS",
    "year": 2012,
    "answer": "protobowl",
    "round": "Round_10_HSAPQ4Q.pdf"
  }
];

fisher_yates = function(i) {
  var arr, j, _i, _ref, _results;
  if (i === 0) {
    return [];
  }
  arr = (function() {
    _results = [];
    for (var _i = 0; 0 <= i ? _i < i : _i > i; 0 <= i ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  while (--i) {
    j = Math.floor(Math.random() * (i + 1));
    _ref = [arr[j], arr[i]], arr[i] = _ref[0], arr[j] = _ref[1];
  }
  return arr;
};

question_schedule = [];

getQuestion = function() {
  if (question_schedule.length === 0) {
    question_schedule = fisher_yates(questions.length);
  }
  if (sync.difficulty || sync.category) {
    question_schedule = question_schedule.filter(function(e) {
      var q;
      q = questions[e];
      if (sync.difficulty && q.difficulty !== sync.difficulty) {
        return false;
      }
      if (sync.category && q.category !== sync.category) {
        return false;
      }
      return true;
    });
  }
  return questions[question_schedule.shift()] || {
    'category': 'Error',
    'difficulty': 'Error',
    'num': 'Error',
    'tournament': 'Error Cup',
    'question': 'This type of event occurs when the queried database returns an invalid question and is frequently indicative of a set of constraints which yields a null set. For 10 points, name this event which happened right now.',
    'answer': 'error',
    'year': 1995,
    'round': 'Error'
  };
};

countMatches = function() {
  var a;
  a = questions.filter(function(q) {
    if (sync.difficulty && q.difficulty !== sync.difficulty) {
      return false;
    }
    if (sync.category && q.category !== sync.category) {
      return false;
    }
    return true;
  });
  return a.length;
};

listProps = function(prop) {
  var p, propmap, q, _i, _len;
  propmap = {};
  for (_i = 0, _len = questions.length; _i < _len; _i++) {
    q = questions[_i];
    propmap[q[prop]] = 1;
  }
  return (function() {
    var _results;
    _results = [];
    for (p in propmap) {
      _results.push(p);
    }
    return _results;
  })();
};

virtual_server = {
  pause: function() {
    if (!(sync.attempt || time() > sync.end_time)) {
      return this.freeze();
    }
  },
  unpause: function() {
    if (!sync.attempt) {
      return this.unfreeze();
    }
  },
  set_time: function(ts) {
    return sync.time_offset = serverTime() - ts;
  },
  freeze: function() {
    return sync.time_freeze = time();
  },
  unfreeze: function() {
    if (sync.time_freeze) {
      this.set_time(sync.time_freeze);
      return sync.time_freeze = 0;
    }
  },
  skip: function() {
    return this.new_question();
  },
  next: function() {
    return this.new_question();
  },
  connect: function() {
    var _this = this;
    console.log("initializing server!");
    return loadQuestions(function() {
      var publicID, publicName;
      sock.server_emit("connect");
      publicID = "offline";
      publicName = require('lib/names').generateName();
      sock.server_emit('joined', {
        name: publicName,
        id: publicID
      });
      sync.answer_duration = 1000 * 5;
      sync.time_offset = 0;
      sync.users = [
        {
          guesses: 0,
          interrupts: 0,
          early: 0,
          correct: 0,
          last_action: 0,
          seen: 0,
          id: publicID,
          name: publicName
        }
      ];
      sync.rate = Math.round(1000 * 60 / 3 / 300);
      _this.freeze();
      _this.new_question();
      sock.server_emit('log', {
        user: publicID,
        verb: 'joined the room'
      });
      sync.categories = listProps('category');
      sync.difficulties = listProps('difficulty');
      return setTimeout(function() {
        return synchronize();
      }, 10);
    });
  },
  init_offline: function() {
    return loadQuestions();
  },
  rename: function(name) {
    return users[public_id].name = name;
  },
  difficulty: function(data) {
    sync.difficulty = data;
    return sock.server_emit('log', {
      user: public_id,
      verb: ' set difficulty to ' + (data || 'anything') + (" (" + (countMatches()) + " questions)")
    });
  },
  category: function(data) {
    sync.category = data;
    return sock.server_emit('log', {
      user: public_id,
      verb: ' set category to ' + (data || 'more pot') + (" (" + (countMatches()) + " questions)")
    });
  },
  join: function(data) {
    return alert('deprecated');
  },
  chat: function(msg) {
    var count, pick, reply, session, writeLetter;
    sock.server_emit('chat', {
      text: msg.text,
      session: msg.session,
      user: public_id,
      done: msg.done,
      time: serverTime()
    });
    if (msg.done) {
      if ((typeof replies !== "undefined" && replies !== null) || /lonely/.test(msg.text)) {
        session = Math.random().toString(36).slice(2);
        if (typeof replies !== "undefined" && replies !== null) {
          pick = function(list) {
            return list[Math.floor(list.length * Math.random())];
          };
          if (msg.text.replace(/[^a-z]/g, '') in replies) {
            reply = pick(replies[msg.text.replace(/[^a-z]/g, '')]) + "    ";
          } else {
            reply = pick(Object.keys(replies));
            reply = pick(replies[reply]);
          }
        } else {
          $.ajax({
            url: "lib/chatbot.js",
            cache: true,
            dataType: "script"
          });
          reply = "I'm lonely too. Plz talk to meeeee";
        }
        count = 0;
        writeLetter = function() {
          if (++count <= reply.length) {
            sock.server_emit('chat', {
              text: reply.slice(0, count),
              session: session,
              user: public_id,
              done: count === reply.length,
              time: serverTime()
            });
            return setTimeout(writeLetter, 1000 * 60 / 6 / 130);
          }
        };
        return writeLetter();
      }
    }
  },
  new_question: function() {
    var question, syllables, word;
    sync.attempt = null;
    sync.begin_time = time();
    question = getQuestion();
    sync.info = {
      category: question.category,
      difficulty: question.difficulty,
      tournament: question.tournament,
      num: question.question_num,
      year: question.year,
      round: question.round
    };
    sync.qid = "offline" + Math.random().toString().slice(3);
    sync.question = question.question.replace(/FTP/g, 'For 10 points').replace(/^\[.*?\]/, '').replace(/\n/g, ' ').replace(/\s+/g, ' ');
    sync.answer = question.answer.replace(/\<\w\w\>/g, '').replace(/\[\w\w\]/g, '');
    syllables = require('./lib/syllable').syllables;
    sync.timing = (function() {
      var _i, _len, _ref, _results;
      _ref = sync.question.split(" ");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        word = _ref[_i];
        _results.push(syllables(word) + 1);
      }
      return _results;
    })();
    this.set_speed(sync.rate);
    sync.users[0].seen++;
    return synchronize();
  },
  speed: function(rate) {
    this.set_speed(rate);
    return synchronize();
  },
  set_speed: function(rate) {
    var cumulative, done, duration, elapsed, new_duration, now, remainder;
    now = time();
    cumulative = cumsum(sync.timing, sync.rate);
    elapsed = now - sync.begin_time;
    duration = cumulative[cumulative.length - 1];
    done = elapsed / duration;
    remainder = 0;
    if (done > 1) {
      remainder = elapsed - duration;
      done = 1;
    }
    sync.rate = rate;
    cumulative = cumsum(sync.timing, sync.rate);
    new_duration = cumulative[cumulative.length - 1];
    sync.begin_time = now - new_duration * done - remainder;
    return sync.end_time = sync.begin_time + new_duration + sync.answer_duration;
  },
  guess: function(data) {
    if (sync.attempt) {
      sync.attempt.text = data.text;
      if (data.done) {
        this.end_buzz(sync.attempt.session);
      }
      return synchronize();
    }
  },
  finish: function() {
    return this.set_time(sync.end_time);
  },
  end_buzz: function(session) {
    var checkAnswer, _ref;
    if (((_ref = sync.attempt) != null ? _ref.session : void 0) === session) {
      sync.attempt.done = true;
      checkAnswer = require('./lib/answerparse').checkAnswer;
      sync.attempt.correct = checkAnswer(sync.attempt.text, sync.answer, sync.question);
      synchronize();
      this.unfreeze();
      if (sync.attempt.correct) {
        users[public_id].correct++;
        if (sync.attempt.early) {
          users[public_id].early++;
        }
        this.finish();
      } else if (sync.attempt.interrupt) {
        users[public_id].interrupts++;
      }
      sync.attempt = null;
      return synchronize();
    }
  },
  buzz: function() {
    var cumulative, early_index, session,
      _this = this;
    if (time() <= sync.end_time) {
      session = Math.random().toString(36).slice(2);
      early_index = sync.question.replace(/[^ \*]/g, '').indexOf('*');
      cumulative = cumsum(sync.timing, sync.rate);
      sync.attempt = {
        user: public_id,
        realTime: serverTime(),
        start: time(),
        duration: 8 * 1000,
        session: session,
        text: '',
        early: early_index && time() < sync.begin_time + cumulative[early_index],
        interrupt: time() < sync.end_time - sync.answer_duration,
        done: false
      };
      users[public_id].guesses++;
      this.freeze();
      this.timeout(serverTime, sync.attempt.realTime + sync.attempt.duration, function() {
        return _this.end_buzz(session);
      });
      return 'http://www.whosawesome.com/';
    }
  },
  timeout: function(metric, time, callback) {
    var diff,
      _this = this;
    diff = time - metric();
    if (diff < 0) {
      return callback();
    } else {
      return setTimeout(function() {
        return _this.timeout(metric, time, callback);
      }, diff);
    }
  }
};

loadQuestions = function(fn) {
  return $.ajax('sample.txt').done(function(text) {
    var line;
    questions = (function() {
      var _i, _len, _ref, _results;
      _ref = text.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(JSON.parse(line));
      }
      return _results;
    })();
    if (fn) {
      return fn();
    }
  });
};

if (!(typeof io !== "undefined" && io !== null)) {
  virtual_server.connect();
}
